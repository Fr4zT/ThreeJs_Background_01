<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="description" content="ThreeJs endless tiles">
    <meta name="keywords" content="HTML, CSS, JavaScript, ThreeJs">
    <meta name="author" content="Tommaso Frazzano">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ThreeJs - Endless tiles</title>
    <style>
        body {
            margin: 0px;
            overflow: hidden;
        }

        #threeCanvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <canvas id="threeCanvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/postprocessing@6.28.7/build/postprocessing.js"></script>

    <script type="module">
        import { GUI } from "https://cdn.jsdelivr.net/npm/three@0.145.0/examples/jsm/libs/lil-gui.module.min.js";

        let renderer, camera, scene;
        let composer, renderPass, blurPass;

        const {
            Scene,
            PerspectiveCamera,
            CubeGeometry,
            MeshPhongMaterial,
            Mesh,
            AmbientLight,
            PointLight,
            Color,
            PointLightHelper,
            WebGLRenderer
        } = THREE;


        const { EffectComposer, RenderPass, BlurPass, KernelSize } = POSTPROCESSING;

        let cards = [];

        let xCount = 3;
        let zCount = 10;
        let boxWidth = 5;
        let boxDepht = 1;

        function init() {

            const canvas = document.getElementById("threeCanvas");

            scene = new THREE.Scene();
            scene.background = new THREE.Color("#000000");

            renderer = new THREE.WebGLRenderer({ canvas: canvas });
            renderer.setSize(window.innerWidth, window.innerHeight);

            camera = new THREE.PerspectiveCamera(39.6, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(11, 8, 5);
            camera.position.set(3, 5, -2);

            camera.rotation.set(degToRad(-45), 0, 0);
            camera.lookAt(0, 0, 0);

            composer = new EffectComposer(renderer);

            renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            blurPass = new BlurPass({
                kernelSize: KernelSize.HUGE
            });
            composer.addPass(blurPass);

            const light = new THREE.AmbientLight(0x404040);
            scene.add(light);

            const directionalLight = new THREE.DirectionalLight(0xffffff, .5);
            scene.add(directionalLight);

            const boxGeometry = new THREE.BoxGeometry(boxWidth - .07, 1, boxDepht - .07, 1, 1, 1);

            for (let z = -zCount; z < zCount; z++) {
                let xOffset = THREE.MathUtils.randFloat(0, 5);
                let xSpeed = THREE.MathUtils.randFloat(0.005, 0.02);
                for (let x = -xCount; x < xCount; x++) {

                    const boxMaterial = new THREE.MeshStandardMaterial({ color: randomColor() });
                    let box = new THREE.Mesh(boxGeometry, boxMaterial);
                    box.position.set(x * boxWidth + xOffset, 0, z * boxDepht);
                    cards.push({ box: box, speed: xSpeed });
                    scene.add(box);
                }
            }

            const gui = new GUI();
            const folderConfig = gui.addFolder('Configuration');
            folderConfig.add(parameters, "speedMultiplier", -10, 10, 0.1).name("Speed multiplier");
            folderConfig.addColor(parameters, "color_1").name("Color 1");
            folderConfig.addColor(parameters, "color_2").name("Color 2");
            folderConfig.add(parameters, "blurIntensity", 0, 10, 0.1).name("Blur intensity");
            folderConfig.open();

            onWindowResize();
        }

        function degToRad(deg) {
            return (Math.PI / 180) * deg;
        }

        let toScroll = 0;
        const parameters = {
            speedMultiplier: 1,
            color_1: 0xff0000,
            color_2: 0x0000ff,
            blurIntensity: 0
        };
        function animate() {
            for (let i = 0; i < cards.length; i++) {
                const card = cards[i];
                card.box.position.x += card.speed * parameters.speedMultiplier + toScroll;
                if (card.box.position.x > boxWidth * xCount) {
                    card.box.position.x = -boxWidth * xCount + (card.box.position.x - boxWidth * xCount);
                    card.box.material.color.setHex(randomColor());
                } else if (card.box.position.x < -boxWidth * xCount) {
                    card.box.position.x = boxWidth * xCount + (card.box.position.x + boxWidth * xCount);
                    card.box.material.color.setHex(randomColor());
                }
            }
            if (toScroll != 0) {
                toScroll = lerp(toScroll, 0, 0.1);
            }
            render();
            requestAnimationFrame(animate);
        }

        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end
        }

        function diff(num1, num2) {
            if (num1 > num2) {
                return num1 - num2
            } else {
                return num2 - num1
            }
        }

        function render() {
            blurPass.scale = parameters.blurIntensity;
            composer.render();
        }

        function randomColor() {
            let color = new THREE.Color(0xffffff).lerpColors(new THREE.Color(parameters.color_1), new THREE.Color(parameters.color_2), THREE.MathUtils.randFloat(0, 1)).getHexString();
            console.log(parseInt("0x" + color, 16));
            return parseInt("0x" + color, 16);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onWindowScroll(e) {
            toScroll += e.deltaY / 100;
        }

        init();
        animate();

        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('wheel', onWindowScroll, false);
    </script>



</body>

</html>